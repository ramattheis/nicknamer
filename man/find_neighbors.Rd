% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_neighbors.R
\name{find_neighbors}
\alias{find_neighbors}
\title{Build neighbor list for \code{draw_gibbs()} in parallel}
\usage{
find_neighbors(
  strings,
  method = "jw",
  max_dist = ifelse(method \%in\% c("jw", "cosine", "jaccard"), 0.3, 3),
  ncores = parallel::detectCores()
)
}
\arguments{
\item{strings}{A non‐empty character vector of \strong{unique} strings to compare.
Duplicates will trigger an error.}

\item{method}{Character scalar; distance metric passed to
\code{stringdist::stringdist()}.  Common choices:
- \code{"lv"}: Levenshtein edit distance
- \code{"jw"}: Jaro–Winkler distance (1 − similarity)
- \code{"cosine"}, \code{"jaccard"}, etc.}

\item{max_dist}{Numeric ≥ 0; only those pairs whose distance ≤ \code{max_dist}
are returned as neighbors.  Defaults to 3 for edit
distances and 0.3 for similarity‐based metrics.}

\item{ncores}{Integer ≥ 1; number of parallel worker processes to launch.
Defaults to \code{parallel::detectCores()}.}
}
\value{
A \strong{named} list of length \code{length(strings)}.  Each element is a
two‐element list containing:
\itemize{
\item \code{j}: integer vector of 1-based positions in \code{strings} that are
within \code{max_dist} of the query string,
\item \code{d}: numeric vector of the corresponding distances.
}
}
\description{
\code{find_neighbors()} identifies, for each string in \code{strings}, all other
strings within a specified \code{max_dist} under the chosen \code{method} (e.g. edit
distance \code{"lv"} or Jaro–Winkler \code{"jw"}).  It dispatches the work across
multiple cores, showing progress as each chunk completes.
}
\details{
Internally, \code{find_neighbors()} proceeds as follows:
\enumerate{
\item \strong{Input validation} — ensures \code{strings} is non‐empty, character, and
contains no duplicates.
\item \strong{Worker function} — for a single index \code{i}, computes
\code{stringdist(strings[i], strings, method = method)}, filters
those ≤ \code{max_dist}, and returns \code{j} (indices) and \code{d} (distances).
\item \strong{Cluster setup} — starts a PSOCK cluster with \code{ncores} workers.
\item \strong{Parallel mapping} — uses \code{pbapply::pblapply()} to apply the worker
across all \verb{i ∈ 1:K}, showing a progress bar as chunks finish.
\item \strong{Cleanup & naming} — stops the cluster on exit, assigns the original
strings as names of the output list, and returns.
}
}
\examples{
s <- c("apple","apply","appla","banana","banane")
# Find all within Levenshtein distance 2, on 2 cores:
find_neighbors(s, method = "lv", max_dist = 2, ncores = 2)
# Find all within Jaro–Winkler distance 0.15, on all cores:
find_neighbors(s, method = "jw", max_dist = 0.15)

}
