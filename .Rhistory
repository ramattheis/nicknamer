p     = n / sum(n),
delta = 0.1
)
init <- modifyList(default_init, init)
list2env(init, environment())
# Precompute G kernel lists: normalized exp(-d/λ)
G_list <- vector("list", K)
j_list <- vector("list", K)
for(i in seq_len(K)) {
js <- neighbor_list[[i]]$j
ds <- neighbor_list[[i]]$d
j_list[[i]] <- js
w  <- exp(-ds / lambda)
G_list[[i]] <- w / sum(w)
}
lambda =1
for(i in seq_len(K)) {
js <- neighbor_list[[i]]$j
ds <- neighbor_list[[i]]$d
j_list[[i]] <- js
w  <- exp(-ds / lambda)
G_list[[i]] <- w / sum(w)
}
# Storage for post-burnin
n_save        <- max(n_iter - burnin, 0)
delta_samples <- numeric(n_save)
x_sum         <- numeric(K)
p_sum         <- numeric(K)
# Dirichlet sampler
rdirichlet <- function(alpha) {
y <- rgamma(length(alpha), shape = alpha, rate = 1)
y / sum(y)
}
save_idx <- 0
pb <- txtProgressBar(min = 1, max = n_iter, style = 3)
iter = 1
setTxtProgressBar(pb, iter)
# 1. Sample Z via C++
zz <- sampleZ_cpp(
n             = as.integer(n),
p             = as.numeric(p),
delta         = delta,
neighbor_list = j_list,
G_list        = G_list
)
Z <- sparseMatrix(i = zz$i, j = zz$j, x = zz$x, dims = c(K, K))
# 2. Sufficient stats
T_i <- rowSums(Z)
S   <- sum(diag(Z)); E <- sum(Z) - S
# 3. Update p | Z, x
alpha_vec <- dirichlet_alpha * x + spike_epsilon
p         <- rdirichlet(alpha_vec + T_i)
# 4. Update x | Z
lbf_vec <- lgamma(dirichlet_alpha + spike_epsilon + T_i) - lgamma(dirichlet_alpha + spike_epsilon) -
(lgamma(spike_epsilon + T_i)             - lgamma(spike_epsilon))
log_prior <- log(presence_alpha) - log(presence_beta)
post_odds <- exp(log_prior + lbf_vec)
x         <- rbinom(K, 1, post_odds / (1 + post_odds))
# 5. Update delta | Z
delta <- rbeta(1, error_alpha + E, error_beta + S)
# Store
if(iter > burnin) {
save_idx               <- save_idx + 1
delta_samples[save_idx] <- delta
x_sum <- x_sum + x
p_sum <- p_sum + p
}
for(iter in seq_len(n_iter)) {
setTxtProgressBar(pb, iter)
# 1. Sample Z via C++
zz <- sampleZ_cpp(
n             = as.integer(n),
p             = as.numeric(p),
delta         = delta,
neighbor_list = j_list,
G_list        = G_list
)
Z <- sparseMatrix(i = zz$i, j = zz$j, x = zz$x, dims = c(K, K))
# 2. Sufficient stats
T_i <- rowSums(Z)
S   <- sum(diag(Z)); E <- sum(Z) - S
# 3. Update p | Z, x
alpha_vec <- dirichlet_alpha * x + spike_epsilon
p         <- rdirichlet(alpha_vec + T_i)
# 4. Update x | Z
lbf_vec <- lgamma(dirichlet_alpha + spike_epsilon + T_i) - lgamma(dirichlet_alpha + spike_epsilon) -
(lgamma(spike_epsilon + T_i)             - lgamma(spike_epsilon))
log_prior <- log(presence_alpha) - log(presence_beta)
post_odds <- exp(log_prior + lbf_vec)
x         <- rbinom(K, 1, post_odds / (1 + post_odds))
# 5. Update delta | Z
delta <- rbeta(1, error_alpha + E, error_beta + S)
# Store
if(iter > burnin) {
save_idx               <- save_idx + 1
delta_samples[save_idx] <- delta
x_sum <- x_sum + x
p_sum <- p_sum + p
}
}
close(pb)
list(
delta_samples = delta_samples,
x_avg         = x_sum / n_save,
p_avg         = p_sum / n_save
)
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
library(nicknamer)
# Drawing names
data = synthetic_name_counts()
# Generating list of string-proximal neighbors
neighbor_list = make_neighbor_list(data$name, method = "jw")
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
## For testing
priors = list()
init   = list()
lambda = 1
n_iter = 1000
burnin = 100
Rcpp::sourceCpp(src/sampleZ_cpp.cpp)
Rcpp::sourceCpp("src/sampleZ_cpp.cpp")
#'
#' @useDynLib nicknamer, .registration=TRUE
#' @importFrom Matrix sparseMatrix
#' @import Rcpp
#' @export
#' @examples
#' # Assuming sampleZ_cpp is compiled and available
#' df <- data.frame(string = c("a","b","c"), count = c(10,5,1))
#' nbrs <- list(list(j=c(2),d=c(1)), list(j=c(1,3),d=c(1,2)), list(j=2,d=2))
#' out <- draw_gibbs(df, nbrs, lambda=1, n_iter=100, burnin=10)
draw_gibbs <- function(data,
neighbor_list,
lambda        = 1,
priors        = list(),
init          = list(),
n_iter        = 10000,
burnin        = 1000) {
library(Matrix)
n <- data$count
K <- nrow(data)
# Default priors
default_priors <- list(
presence_alpha  = 1,
presence_beta   = 99,
dirichlet_alpha = 1,
spike_epsilon   = 1e-8,
error_alpha     = 1,
error_beta      = 9
)
priors <- modifyList(default_priors, priors)
list2env(priors, environment())
# Init defaults (λ fixed externally)
default_init <- list(
x     = as.integer(n > mean(n)),
p     = n / sum(n),
delta = 0.1
)
init <- modifyList(default_init, init)
list2env(init, environment())
# Precompute G kernel lists: normalized exp(-d/λ)
G_list <- vector("list", K)
j_list <- vector("list", K)
for(i in seq_len(K)) {
js <- neighbor_list[[i]]$j
ds <- neighbor_list[[i]]$d
j_list[[i]] <- js
w  <- exp(-ds / lambda)
G_list[[i]] <- w / sum(w)
}
# Storage for post-burnin
n_save        <- max(n_iter - burnin, 0)
delta_samples <- numeric(n_save)
x_sum         <- numeric(K)
p_sum         <- numeric(K)
# Dirichlet sampler
rdirichlet <- function(alpha) {
y <- rgamma(length(alpha), shape = alpha, rate = 1)
y / sum(y)
}
save_idx <- 0
pb <- txtProgressBar(min = 1, max = n_iter, style = 3)
for(iter in seq_len(n_iter)) {
setTxtProgressBar(pb, iter)
# 1. Sample Z via C++
zz <- sampleZ_cpp(
n             = as.integer(n),
p             = as.numeric(p),
delta         = delta,
neighbor_list = j_list,
G_list        = G_list
)
Z <- sparseMatrix(i = zz$i, j = zz$j, x = zz$x, dims = c(K, K))
# 2. Sufficient stats
T_i <- rowSums(Z)
S   <- sum(diag(Z)); E <- sum(Z) - S
# 3. Update p | Z, x
alpha_vec <- dirichlet_alpha * x + spike_epsilon
p         <- rdirichlet(alpha_vec + T_i)
# 4. Update x | Z
lbf_vec <- lgamma(dirichlet_alpha + spike_epsilon + T_i) - lgamma(dirichlet_alpha + spike_epsilon) -
(lgamma(spike_epsilon + T_i)             - lgamma(spike_epsilon))
log_prior <- log(presence_alpha) - log(presence_beta)
post_odds <- exp(log_prior + lbf_vec)
x         <- rbinom(K, 1, post_odds / (1 + post_odds))
# 5. Update delta | Z
delta <- rbeta(1, error_alpha + E, error_beta + S)
# Store
if(iter > burnin) {
save_idx               <- save_idx + 1
delta_samples[save_idx] <- delta
x_sum <- x_sum + x
p_sum <- p_sum + p
}
}
close(pb)
list(
delta_samples = delta_samples,
x_avg         = x_sum / n_save,
p_avg         = p_sum / n_save
)
}
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
out$x_avg
plot(out$x_avg, out$p_avg)
plot(log(out$x_avg), log(out$p_avg) )
Rcpp::compileAttributes()
devtools::document()
devtools::document()
devtools::install()
library(nicknamer)
# Drawing names
data = synthetic_name_counts()
devtools::build()
devtools::install()
library(nicknamer)
# Drawing names
data = synthetic_name_counts()
# Generating list of string-proximal neighbors
neighbor_list = make_neighbor_list(data$name, method = "jw")
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
getLoadedDLLs()
library(nicknamer)
getLoadedDLLs()
dlls <- getLoadedDLLs()
names(dlls)
# pick the nicknamer entry:
dll <- dlls[["nicknamer"]]
str(dll)       # shows path, registration info
# now try each possible name:
for(sym in c("_nicknamer_sampleZ_cpp","nicknamer_sampleZ_cpp","sampleZ_cpp")){
cat(sym,": ")
print( tryCatch(getNativeSymbolInfo(sym, dll), error=function(e) e$message) )
}
library(nicknamer)
getNativeSymbolInfo("_nicknamer_sampleZ_cpp", PACKAGE="nicknamer")
args(sampleZ_cpp)
devtools::document()
devtools::build()
devtools::install()
library(nicknamer)
# Drawing names
data = synthetic_name_counts()
# Generating list of string-proximal neighbors
neighbor_list = make_neighbor_list(data$name, method = "jw")
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
args(sampleZ_cpp)
ls(getNamespace("nicknamer"))
# 1a) list everything in the package namespace
ls(getNamespace("nicknamer"))
# 1b) list the exported functions
getNamespaceExports("nicknamer")
#'
#' @useDynLib nicknamer, .registration=TRUE
#' @importFrom Matrix sparseMatrix
#' @import Rcpp
#' @export
#' @examples
#' # Assuming sampleZ_cpp is compiled and available
#' df <- data.frame(string = c("a","b","c"), count = c(10,5,1))
#' nbrs <- list(list(j=c(2),d=c(1)), list(j=c(1,3),d=c(1,2)), list(j=2,d=2))
#' out <- draw_gibbs(df, nbrs, lambda=1, n_iter=100, burnin=10)
draw_gibbs <- function(data,
neighbor_list,
lambda        = 1,
priors        = list(),
init          = list(),
n_iter        = 10000,
burnin        = 1000) {
library(Matrix)
n <- data$count
K <- nrow(data)
# Default priors
default_priors <- list(
presence_alpha  = 1,
presence_beta   = 99,
dirichlet_alpha = 1,
spike_epsilon   = 1e-8,
error_alpha     = 1,
error_beta      = 9
)
priors <- modifyList(default_priors, priors)
list2env(priors, environment())
# Init defaults (λ fixed externally)
default_init <- list(
x     = as.integer(n > mean(n)),
p     = n / sum(n),
delta = 0.1
)
init <- modifyList(default_init, init)
list2env(init, environment())
# Precompute G kernel lists: normalized exp(-d/λ)
G_list <- vector("list", K)
j_list <- vector("list", K)
for(i in seq_len(K)) {
js <- neighbor_list[[i]]$j
ds <- neighbor_list[[i]]$d
j_list[[i]] <- js
w  <- exp(-ds / lambda)
G_list[[i]] <- w / sum(w)
}
# Storage for post-burnin
n_save        <- max(n_iter - burnin, 0)
delta_samples <- numeric(n_save)
x_sum         <- numeric(K)
p_sum         <- numeric(K)
# Dirichlet sampler
rdirichlet <- function(alpha) {
y <- rgamma(length(alpha), shape = alpha, rate = 1)
y / sum(y)
}
save_idx <- 0
pb <- txtProgressBar(min = 1, max = n_iter, style = 3)
for(iter in seq_len(n_iter)) {
setTxtProgressBar(pb, iter)
# 1. Sample Z via C++
zz <- sampleZ_cpp(
n             = as.integer(n),
p             = as.numeric(p),
delta         = delta,
neighbor_list = j_list,
G_list        = G_list
)
Z <- sparseMatrix(i = zz$i, j = zz$j, x = zz$x, dims = c(K, K))
# DEBUGGING
browser()
# 2. Sufficient stats
T_i <- rowSums(Z)
S   <- sum(diag(Z)); E <- sum(Z) - S
# 3. Update p | Z, x
alpha_vec <- dirichlet_alpha * x + spike_epsilon
p         <- rdirichlet(alpha_vec + T_i)
# 4. Update x | Z
lbf_vec <- lgamma(dirichlet_alpha + spike_epsilon + T_i) - lgamma(dirichlet_alpha + spike_epsilon) -
(lgamma(spike_epsilon + T_i)             - lgamma(spike_epsilon))
log_prior <- log(presence_alpha) - log(presence_beta)
post_odds <- exp(log_prior + lbf_vec)
x         <- rbinom(K, 1, post_odds / (1 + post_odds))
# 5. Update delta | Z
delta <- rbeta(1, error_alpha + E, error_beta + S)
# Store
if(iter > burnin) {
save_idx               <- save_idx + 1
delta_samples[save_idx] <- delta
x_sum <- x_sum + x
p_sum <- p_sum + p
}
}
close(pb)
list(
delta_samples = delta_samples,
x_avg         = x_sum / n_save,
p_avg         = p_sum / n_save
)
}
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
Rcpp::sourceCpp("src/sampleZ_cpp.cpp")
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
str(Z)
devtools::document()
devtools::install()
library(nicknamer)
# Drawing names
data = synthetic_name_counts()
# Generating list of string-proximal neighbors
neighbor_list = make_neighbor_list(data$name, method = "jw")
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
T_i <- rowSums(Z)
devtools::document()
devtools::install()
library(nicknamer)
# Drawing names
data = synthetic_name_counts()
# Generating list of string-proximal neighbors
neighbor_list = make_neighbor_list(data$name, method = "jw")
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
devtools::document()
devtools::install()
library(nicknamer)
# Drawing names
data = synthetic_name_counts()
# Generating list of string-proximal neighbors
neighbor_list = make_neighbor_list(data$name, method = "jw")
# Drawing the posterior
out = draw_gibbs(data, neighbor_list)
out$delta_samples
plot(out$delta_samples)
plot(out$x_avg)
plot(density(out$x_avg))
raw_names = read.csv("misc/chunk.csv")
raw_names = raw_names$namelast
# 1) lowercase & strip spaces/apostrophes
cleaned <- tolower(raw_names)
cleaned <- gsub("[ ']", "", cleaned)
# 2) count length & non-alphanumeric chars
lens <- nchar(cleaned)
non_alnum <- nchar(gsub("[[:alnum:]]", "", cleaned))
# 3) blank out any 1-char names or >50% non-alnum
bad <- lens <= 1 | (non_alnum / pmax(lens, 1)) > 0.5
cleaned[bad] <- ""
# 4) tabulate and return sorted data.frame
tbl <- table(cleaned, useNA = "no")
df  <- data.frame(
name  = names(tbl),
count = as.integer(tbl),
stringsAsFactors = FALSE
)
df <- df[order(-df$count), , drop = FALSE]
rownames(df) <- NULL
head(df)
tail(df)
raw_names = read.csv("misc/chunk.csv")
raw_names = raw_names$namelast
summary(as.factor(raw_names))
cleaned = raw_names
# 4) tabulate and return sorted data.frame
tbl <- table(cleaned, useNA = "no")
df  <- data.frame(
name  = names(tbl),
count = as.integer(tbl),
stringsAsFactors = FALSE
)
df <- df[order(-df$count), , drop = FALSE]
View(df)
trail = lapply(strsplit(raw_names, " "),"[[",2)
# Suppose cleaned_names is your character vector
last_piece <- sapply(strsplit(raw_names, "\\s+"), tail, 1)
# Look at the most common “endings”
sort(table(last_piece), decreasing = TRUE)
# Suppose cleaned_names is your character vector
last_piece <- sapply(strsplit(raw_names[grepl("\\s+",raw_names)], "\\s+"), tail, 1)
# Look at the most common “endings”
sort(table(last_piece), decreasing = TRUE)
raw_names
# 1) lowercase
cleaned <- tolower(raw_names)
# 2) removes jr / sr / etc
cleaned <- gsub("\\s+(jr|sr)\\.?$", "", cleaned)
# 3) strip spaces/apostrophes
cleaned <- gsub("[ ']", "", cleaned)
# 4) Remove "missing letter" symbols
cleaned <- gsub("(?<=[A-Za-z])[^A-Za-z0-9](?=[A-Za-z])", "", cleaned, perl=TRUE)
tbl <- table(cleaned, useNA = "no")
df  <- data.frame(
name  = names(tbl),
count = as.integer(tbl),
stringsAsFactors = FALSE
)
df <- df[order(-df$count), , drop = FALSE]
View(df)
# 1) lowercase
cleaned <- tolower(raw_names)
# 2) removes jr / sr / etc
cleaned <- gsub("\\s+(jr|sr)\\.?$", "", cleaned)
# 3) strip spaces/apostrophes
cleaned <- gsub("[ ']", "", cleaned)
# 4) remove "missing letter" symbols
cleaned <- gsub( "(?<=[a-z])[^a-z]{1,2}(?=[a-z])", "", cleaned, perl = TRUE)
cleaned <- gsub( "(^[^a-z]{1,2}(?=[a-z]{2}))|((?<=[a-z]{2})[^a-z]{1,2}$)", "", cleaned, perl = TRUE)
# 6) removing numbers
cleaned <- gsub("[0-9]","",cleaned)
# 7) blank out names with any remaining non-letters
cleaned[ grepl("[^a-z]","",cleaned)] = ""
# 8) blank out any 1-char names or uncommon 2-char names
cleaned[ nchar(cleaned) <= 1 ] = ""
twochar = cleaned[nchar(cleaned) == 2]
twochar
# 8) blank out any 1-char names or uncommon 2-char names
cleaned[ nchar(cleaned) <= 1 ] = ""
cleaned[ nchar(cleaned) <= 2 & !(cleaned %in% c(
"ah", "ng", "ho", "ma", "ha", "lu", "la", "ba",
"on", "wo", "ba", "an", "le", "un", "lo", "mo",
"ca", "bo", "wa", "li", "go", "co", "he", "wu",
"su", "da", "jo", "yu", "bu", "hi", "ko", "me",
"ek", "ax", "re", "sy", "ey", "ox"
) )] = ""
twochars = c( "ah", "ng", "ho", "ma", "ha", "lu", "la", "ba", "on", "wo",
"ba", "an", "le", "un", "lo", "mo", "ca", "bo", "wa", "li",
"go", "co", "he", "wu", "su", "da", "jo", "yu", "bu", "hi",
"ko", "me", "ek", "ax", "re", "sy", "ey", "ox")
devtools::document()
devtools::install()
?clean_surnames
